<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Weather Dashboard</title>
  <!--import tailwindcss-->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: {
              50: '#f0f9ff',
              100: '#e0f2fe',
              200: '#bae6fd',
              300: '#7dd3fc',
              400: '#38bdf8',
              500: '#0ea5e9',
              600: '#0284c7',
              700: '#0369a1',
              800: '#075985',
              900: '#0c4a6e',
            },
            secondary: {
              50: '#f8fafc',
              100: '#f1f5f9',
              200: '#e2e8f0',
              300: '#cbd5e1',
              400: '#94a3b8',
              500: '#64748b',
              600: '#475569',
              700: '#334155',
              800: '#1e293b',
              900: '#0f172a',
            },
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
        },
      },
    };
  </script>
  <!--import leaflet for the interactive map-->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" /> 
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Import Chart.js and its annotation plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
  <!-- Import Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <!-- Import Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    .legend.leaflet-control {
      padding: 0;
      margin: 0;
    }
    .legend-container {
      min-width: 200px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .legend-color {
      display: inline-block;
      border: 1px solid rgba(0,0,0,0.2);
    }
    .legend-item {
      padding: 4px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    .legend-item:hover {
      background-color: rgba(0,0,0,0.05);
    }
    .popup-content {
      padding: 10px;
      min-width: 200px;
    }
    .popup-content h3 {
      margin: 0 0 8px 0;
      padding-bottom: 4px;
      border-bottom: 1px solid #eee;
    }
    .popup-content p {
      margin: 4px 0;
    }
    body {
      font-family: 'Inter', sans-serif;
      background-color: #0f172a;
      color: #f8fafc;
    }
    .card {
      background-color: #1e293b;
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
     
    }
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    .nav-link {
      transition: background-color 0.3s ease, color 0.3s ease;
      border-radius: 0.375rem;
      padding: 0.5rem 1rem;
    }
    .nav-link:hover {
      background-color: #334155;
    }
    .nav-link.active {
      background-color: #0ea5e9;
      color: white;
    }
    .btn {
      transition: all 0.3s ease;
    }
    .btn:hover {
      transform: translateY(-1px);
    }
    .btn:active {
      transform: translateY(1px);
    }
    .weather-card {
      background: linear-gradient(to bottom right, #1e293b, #334155);
    }
    .dashboard-header {
      background: linear-gradient(90deg, #0f172a, #1e293b);
      border-bottom: 1px solid #334155;
    }
    .map-container {
      border-radius: 0.5rem;
      overflow: hidden;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    .chart-container {
      border-radius: 0.5rem;
      background-color: #1e293b;
      padding: 1rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    /* Add these new styles */
    .sun-progress {
      position: relative;
      width: 100%;
      height: 3px;
      background: rgba(255,255,255,0.2);
      border-radius: 10px;
      overflow: hidden;
    }

    .sun-indicator {
      position: absolute;
      width: 20px;
      height: 20px;
      background: #ffd700;
      border-radius: 50%;
      box-shadow: 0 0 10px #ffd700;
      transform: translateY(-50%);
      transition: left 0.3s ease;
    }

    .circular-progress {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .circular-progress::before {
      content: '';
      position: absolute;
      width: 54px;
      height: 54px;
      border-radius: 50%;
      background-color: rgba(255,255,255,0.1);
    }

    .progress-value {
      position: relative;
      font-size: 14px;
      font-weight: 600;
      color: white;
    }

    .weather-icon {
      font-size: 24px;
      margin-bottom: 8px;
    }

    .weather-card {
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .weather-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .fade-in {
      animation: fadeIn 0.5s ease-in;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .pulse {
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .weather-value {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 8px 0;
    }

    .weather-label {
      font-size: 0.875rem;
      color: rgba(255,255,255,0.7);
    }

    .uv-indicator {
      width: 100%;
      height: 4px;
      background: linear-gradient(to right, 
        #3EC73E 0%, #3EC73E 20%,    /* Low */
        #F7D047 20%, #F7D047 40%,   /* Moderate */
        #F77F47 40%, #F77F47 60%,   /* High */
        #F74747 60%, #F74747 80%,   /* Very High */
        #904790 80%, #904790 100%   /* Extreme */
      );
      border-radius: 2px;
      margin-top: 8px;
    }

    .uv-marker {
      width: 4px;
      height: 8px;
      background: white;
      border-radius: 2px;
      transform: translateY(-2px);
      transition: margin-left 0.3s ease;
    }

    /* Updated and new styles */
    .weather-card {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .weather-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    }

    .weather-card:hover {
      transform: translateY(-2px);
      background: rgba(255, 255, 255, 0.08);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }

    .weather-value {
      font-size: 2rem;
      font-weight: 700;
      background: linear-gradient(120deg, #fff, rgba(255, 255, 255, 0.7));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 0.5rem 0;
      transition: all 0.3s ease;
    }

    .weather-card:hover .weather-value {
      transform: scale(1.05);
    }

    .weather-icon {
      font-size: 1.5rem;
      opacity: 0.8;
      transition: all 0.3s ease;
    }

    .weather-card:hover .weather-icon {
      opacity: 1;
      transform: rotate(360deg);
    }

    .sun-progress {
      position: relative;
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      overflow: hidden;
      margin: 8px 0;
    }

    .sun-indicator {
      position: absolute;
      width: 16px;
      height: 16px;
      background: #ffd700;
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
      transform: translateY(-50%);
      transition: left 0.3s ease;
      animation: glow 2s infinite;
    }

    @keyframes glow {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); }
      50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
    }

    .circular-progress {
      width: 80px;
      height: 80px;
      margin: 10px auto;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .circular-progress::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: conic-gradient(
        from 0deg,
        rgba(255, 255, 255, 0.8) var(--progress),
        rgba(255, 255, 255, 0.1) var(--progress)
      );
      mask: radial-gradient(transparent 55%, white 56%);
      -webkit-mask: radial-gradient(transparent 55%, white 56%);
    }

    .progress-value {
      font-size: 1.2rem;
      font-weight: 600;
      color: white;
      animation: fadeIn 0.5s ease-out;
    }

    .uv-indicator {
      width: 100%;
      height: 6px;
      background: linear-gradient(to right,
        #3EC73E 0%, #3EC73E 20%,
        #F7D047 20%, #F7D047 40%,
        #F77F47 40%, #F77F47 60%,
        #F74747 60%, #F74747 80%,
        #904790 80%, #904790 100%
      );
      border-radius: 3px;
      margin: 8px 0;
      position: relative;
      overflow: hidden;
    }

    .uv-marker {
      width: 6px;
      height: 12px;
      background: white;
      border-radius: 3px;
      transform: translateY(-3px);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      transition: margin-left 0.3s ease;
    }

    .uv-label {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.8);
      margin-top: 4px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .weather-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 0.5rem;
    }

    .time-range {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 4px;
    }

    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .weather-unit {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.9);
      margin-left: 4px;
      font-weight: 500;
    }

    .fade-in {
      animation: fadeIn 0.5s ease-out;
    }

    .grid-cols-4 {
      grid-template-columns: repeat(4, 1fr);
    }

    @media (max-width: 1024px) {
      .grid-cols-4 {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 640px) {
      .grid-cols-4 {
        grid-template-columns: 1fr;
      }
    }

    /* Add these new styles */
    .weather-description {
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.6);
      margin-top: 0.5rem;
      line-height: 1.2;
    }

    .weather-card {
      min-height: 180px;
      display: flex;
      flex-direction: column;
    }

    .weather-content {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .weather-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .grid-container {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
      margin-bottom: 1rem;
    }

    @media (max-width: 1024px) {
      .grid-container {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 640px) {
      .grid-container {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body class="bg-secondary-900 text-secondary-50 min-h-screen">
  <!-- Header -->
  <header class="dashboard-header py-4 px-6 flex items-center justify-between shadow-md">
    <div class="flex items-center">
      <i class="fas fa-cloud-sun text-4xl text-primary-400 mr-3"></i>
      <h1 class="text-2xl font-bold">Australian Weather Dashboard</h1>
    </div>
  </header>

  <div class="flex min-h-screen">
    <!-- Sidebar -->
    <aside class="w-64 bg-secondary-800 p-6 space-y-6 shadow-lg">
      <nav>
        <h2 class="text-xl font-bold mb-4 text-secondary-100">Navigation</h2>
        <ul class="space-y-2">
          <li>
            <button onclick="showSection('current')" class="nav-link active w-full text-left flex items-center">
              <i class="fas fa-cloud-sun mr-2"></i>
              <span>Current Weather</span>
            </button>
          </li>
          <li>
            <button onclick="showSection('map')" class="nav-link w-full text-left flex items-center">
              <i class="fas fa-map-marked-alt mr-2"></i>
              <span>Weather Map</span>
            </button>
          </li>
          <li>
            <button onclick="showSection('past')" class="nav-link w-full text-left flex items-center">
              <i class="fas fa-chart-line mr-2"></i>
              <span>Weather Trends</span>
            </button>
          </li>
          <li>
            <button onclick="showSection('settings')" class="nav-link w-full text-left flex items-center">
              <i class="fas fa-cog mr-2"></i>
              <span>Settings</span>
            </button>
          </li>
        </ul>
      </nav>
      
      <div class="border-t border-secondary-700 pt-6">
        <h2 class="text-xl font-bold mb-4 text-secondary-100">Cities</h2>
        <ul class="space-y-1 text-secondary-300">
          <li class="flex items-center"><i class="fas fa-map-marker-alt mr-2 text-xs"></i> Melbourne</li>
          <li class="flex items-center"><i class="fas fa-map-marker-alt mr-2 text-xs"></i> Sydney</li>
          <li class="flex items-center"><i class="fas fa-map-marker-alt mr-2 text-xs"></i> Brisbane</li>
          <li class="flex items-center"><i class="fas fa-map-marker-alt mr-2 text-xs"></i> Perth</li>
          <li class="flex items-center"><i class="fas fa-map-marker-alt mr-2 text-xs"></i> Adelaide</li>
          <li class="flex items-center"><i class="fas fa-map-marker-alt mr-2 text-xs"></i> Canberra</li>
        </ul>
      </div>
      
      <div class="border-t border-secondary-700 pt-6">
        <h2 class="text-md font-semibold mb-2 text-secondary-300">Data Source</h2>
        <p class="text-sm text-secondary-400">Weather data provided by Open-Meteo API</p>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="flex-1 p-4 overflow-auto">
      <!-- Current Weather Section -->
      <div id="current">
        <div class="grid grid-cols-1 gap-3">
          <!-- Top Section with Controls -->
          <section class="card p-4 mb-2">
            <div class="flex flex-col md:flex-row md:items-center md:justify-between">
              <h1 class="text-xl font-bold text-secondary-100 mb-2 md:mb-0">Current Weather</h1>
              <div class="flex flex-row gap-2 items-center">
                <button onclick="locateUser()" class="btn bg-primary-600 hover:bg-primary-700 px-3 py-2 rounded flex items-center justify-center">
                  <i class="fas fa-location-crosshairs mr-2"></i> Use My Location
                </button>
                <select id="currentCitySelect" class="bg-secondary-800 text-secondary-100 px-3 py-2 rounded border border-secondary-700">
                  <option value="melbourne">Melbourne</option>
                  <option value="sydney">Sydney</option>
                  <option value="brisbane">Brisbane</option>
                  <option value="perth">Perth</option>
                  <option value="adelaide">Adelaide</option>
                  <option value="canberra">Canberra</option>
                </select>
              </div>
            </div>
          </section>

          <!-- Weather Cards -->
          <section>
            <div id="cards" class="grid-container"></div>
          </section>

          <!-- Forecast Section -->
          <section class="card p-6">
            <div class="mb-6">
              <h2 class="text-2xl font-bold mb-6 text-secondary-100">Next 7 Days Forecast</h2>
              <div class="mb-6 flex justify-center gap-4">
                <select id="forecastCityA" class="bg-secondary-800 text-secondary-100 px-4 py-2 rounded border border-secondary-700">
                  <option value="melbourne">Melbourne</option>
                  <option value="sydney">Sydney</option>
                  <option value="brisbane">Brisbane</option>
                  <option value="perth">Perth</option>
                  <option value="adelaide">Adelaide</option>
                  <option value="canberra">Canberra</option>
                </select>
                <select id="forecastCityB" class="bg-secondary-800 text-secondary-100 px-4 py-2 rounded border border-secondary-700">
                  <option value="sydney">Sydney</option>
                  <option value="melbourne">Melbourne</option>
                  <option value="brisbane">Brisbane</option>
                  <option value="perth">Perth</option>
                  <option value="adelaide">Adelaide</option>
                  <option value="canberra">Canberra</option>
                </select>
              </div>
            </div>
            <div class="chart-container">
              <canvas id="forecastChart" class="w-full max-h-[400px] h-[320px]"></canvas>
            </div>
            <div class="flex justify-end mt-4">
              <button onclick="downloadChartImageLocal(forecastChart, 'forecast_comparison.png')"
                class="btn px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white rounded flex items-center">
                <i class="fas fa-download mr-2"></i> Download Chart
              </button>
            </div>
          </section>
        </div>
      </div>

      <!-- Map Section -->
      <div id="map-section" class="hidden">
        <div class="grid grid-cols-1 gap-3">
          <!-- Map Controls -->
          <section class="card p-4 mb-2">
            <div class="flex items-center justify-between">
              <h1 class="text-xl font-bold text-secondary-100">Weather Map</h1>
              <div class="flex gap-2">
                <button onclick="locateUser()" class="btn bg-primary-600 hover:bg-primary-700 px-3 py-2 rounded flex items-center justify-center">
                  <i class="fas fa-location-crosshairs mr-2"></i> Use My Location
                </button>
              </div>
            </div>
          </section>

          <!-- Map Container -->
          <section class="flex-1">
            <div class="card p-0 map-container h-[calc(100vh-10rem)]">
              <div id="map" class="w-full h-full"></div>
            </div>
          </section>
            </div>
          </div>

      <!-- Past Weather Section -->
      <div id="past" class="hidden">
        <div class="grid grid-cols-1 gap-3">
          <!-- Header with Title and Controls -->
          <section class="card p-4 mb-2">
            <h1 class="text-xl font-bold mb-2 text-secondary-100">Weather Trends Analysis</h1>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
              <div class="space-y-2">
                <h3 class="text-base font-semibold text-secondary-200">City Comparison</h3>
                <div class="flex flex-wrap gap-2">
                  <select id="pastCitySelectA" class="bg-secondary-800 text-secondary-100 px-3 py-2 rounded border border-secondary-700"></select>
                  <select id="pastCitySelectB" class="bg-secondary-800 text-secondary-100 px-3 py-2 rounded border border-secondary-700"></select>
                  </div>
                </div>
              <div class="space-y-2">
                <h3 class="text-base font-semibold text-secondary-200">Time Period</h3>
                <div class="flex flex-wrap gap-2">
                  <select id="yearSelect" class="bg-secondary-800 text-secondary-100 px-3 py-2 rounded border border-secondary-700"></select>
                  <select id="monthSelect" class="bg-secondary-800 text-secondary-100 px-3 py-2 rounded border border-secondary-700">
                      <option value="01">January</option>
                      <option value="02">February</option>
                      <option value="03">March</option>
                      <option value="04">April</option>
                      <option value="05">May</option>
                      <option value="06">June</option>
                      <option value="07">July</option>
                      <option value="08">August</option>
                      <option value="09">September</option>
                      <option value="10">October</option>
                      <option value="11">November</option>
                      <option value="12">December</option>
                    </select>
                  </div>
                </div>
              </div>
            </section>

            <!-- Daily Comparison Charts -->
            <section class="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <div class="card p-6">
                <h2 class="text-xl font-semibold mb-4 text-secondary-100">Daily Temperature Comparison</h2>
                <div class="chart-container">
                  <canvas id="tempChart" class="w-full max-h-[400px] h-[320px]"></canvas>
                </div>
                <div class="flex justify-end mt-4">
                  <button onclick="downloadChartImageLocal(tempChart, 'daily_temperature.png')"
                    class="btn px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white rounded flex items-center">
                    <i class="fas fa-download mr-2"></i> Download Chart
                  </button>
                </div>
              </div>

              <div class="card p-6">
                <h2 class="text-xl font-semibold mb-4 text-secondary-100">Daily Rainfall Comparison</h2>
                <div class="chart-container">
                  <canvas id="rainChart" class="w-full max-h-[400px] h-[320px]"></canvas>
                </div>
                <div class="flex justify-end mt-4">
                  <button onclick="downloadChartImageLocal(rainChart, 'daily_rainfall.png')"
                    class="btn px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white rounded flex items-center">
                    <i class="fas fa-download mr-2"></i> Download Chart
                  </button>
                </div>
              </div>
            </section>

          <!-- Annual Pattern Section -->
          <section class="card p-6">
            <h2 class="text-xl font-semibold mb-4 text-secondary-100">Annual Temperature Pattern</h2>
            <div class="flex flex-wrap items-center gap-4 mb-6">
              <select id="annualCitySelect" class="bg-secondary-800 text-secondary-100 px-4 py-2 rounded border border-secondary-700">
                    <option value="melbourne">Melbourne</option>
                    <option value="sydney">Sydney</option>
                    <option value="brisbane">Brisbane</option>
                    <option value="perth">Perth</option>
                    <option value="adelaide">Adelaide</option>
                    <option value="canberra">Canberra</option>
                  </select>
              <select id="annualYearSelect" class="bg-secondary-800 text-secondary-100 px-4 py-2 rounded border border-secondary-700"></select>
                </div>
                <div class="chart-container">
              <canvas id="annualPatternChart" class="w-full max-h-[400px] h-[320px]"></canvas>
                </div>
                <div class="flex justify-end mt-4">
              <button onclick="downloadChartImageLocal(annualPatternChart, 'annual_pattern.png')"
                    class="btn px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white rounded flex items-center">
                    <i class="fas fa-download mr-2"></i> Download Chart
                  </button>
                </div>
          </section>

          <!-- Historical Extremes -->
          <section class="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <div class="card p-6">
              <h2 class="text-xl font-semibold mb-4 text-secondary-100">Temperature Extremes</h2>
                <div class="chart-container">
                <canvas id="extremesChart" class="w-full max-h-[400px] h-[320px]"></canvas>
                </div>
                <div class="flex justify-end mt-4">
                <button onclick="downloadChartImageLocal(extremesChart, 'temperature_extremes.png')"
                    class="btn px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white rounded flex items-center">
                    <i class="fas fa-download mr-2"></i> Download Chart
                  </button>
                </div>
              </div>
            <div class="card p-6">
              <h2 class="text-xl font-semibold mb-4 text-secondary-100">Monthly Rainfall Averages</h2>
              <div class="chart-container">
                <canvas id="monthlyRainChart" class="w-full max-h-[400px] h-[320px]"></canvas>
              </div>
              <div class="flex justify-end mt-4">
                <button onclick="downloadChartImageLocal(monthlyRainChart, 'monthly_rainfall.png')"
                  class="btn px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white rounded flex items-center">
                  <i class="fas fa-download mr-2"></i> Download Chart
                </button>
              </div>
              </div>
            </section>

            <!-- Long-term Trend Analysis -->
          <section class="card p-6">
              <h2 class="text-xl font-semibold mb-4 text-secondary-100">Temperature Trend Analysis</h2>
              <div class="flex flex-wrap items-center gap-4 mb-6">
                <select id="trendCitySelect" class="bg-secondary-800 text-secondary-100 px-4 py-2 rounded border border-secondary-700">
                  <option value="melbourne">Melbourne</option>
                  <option value="sydney">Sydney</option>
                  <option value="brisbane">Brisbane</option>
                  <option value="perth">Perth</option>
                  <option value="adelaide">Adelaide</option>
                  <option value="canberra">Canberra</option>
                </select>
                <div class="flex items-center gap-2">
                  <label class="text-sm text-secondary-300">From:</label>
                  <select id="trendStartYear" class="bg-secondary-800 text-secondary-100 px-4 py-2 rounded border border-secondary-700"></select>
                  <label class="text-sm text-secondary-300">To:</label>
                  <select id="trendEndYear" class="bg-secondary-800 text-secondary-100 px-4 py-2 rounded border border-secondary-700"></select>
                </div>
              </div>
              <div class="chart-container">
                <canvas id="trendChart" class="w-full max-h-[400px] h-[320px]"></canvas>
              </div>
              <div class="flex justify-end mt-4">
                <button onclick="downloadChartImageLocal(trendChart, 'temperature_trend.png')"
                  class="btn px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white rounded flex items-center">
                  <i class="fas fa-download mr-2"></i> Download Chart
                </button>
              </div>
            </section>
          </div>
      </div>

      <!-- Settings Section -->
      <div id="settings" class="hidden">
        <div class="grid grid-cols-1 gap-6">
          <section class="card p-6">
            <h1 class="text-3xl font-bold mb-6 text-secondary-100">Settings</h1>
            
            <!-- Unit Settings -->
            <div class="space-y-6">
              <div class="flex items-center justify-between p-4 bg-secondary-800 rounded-lg">
                <div>
                  <h3 class="text-lg font-semibold text-secondary-100">Unit System</h3>
                  <p class="text-sm text-secondary-400">Switch between metric (°C, km/h) and imperial (°F, mph) units</p>
                </div>
                <label class="relative inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="sr-only peer" id="unitToggleSwitch" onchange="toggleUnits()">
                  <div class="w-11 h-6 bg-secondary-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-secondary-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-600"></div>
                  <span class="ml-3 text-sm font-medium text-secondary-300" id="unitLabel">Metric (°C)</span>
                </label>
              </div>
            </div>
          </section>
        </div>
      </div>
    </main>
  </div>

  <!-- Footer -->
  <footer class="bg-secondary-800 text-secondary-400 py-4 px-6 text-center text-sm">
    <p>&copy; 2023 Australian Weather Dashboard. Weather data provided by Open-Meteo API.</p>
  </footer>

  <script>
    // Global variables
    let map;
    let popup;
    let currentMarker;
    let cityMarkers = {};
    let useMetric = true;
    let forecastChart;
    let tempChart;
    let rainChart;
    let annualPatternChart;
    let extremesChart;
    let monthlyRainChart;
    let trendChart;
    let temperatureLayer;
    let rainfallLayer;
    let currentLayer = 'temperature';

    // Weather code to icon mapping
    const weatherIcons = {
      0: 'https://openweathermap.org/img/wn/01d@2x.png', // Clear sky
      1: 'https://openweathermap.org/img/wn/02d@2x.png', // Mainly clear
      2: 'https://openweathermap.org/img/wn/03d@2x.png', // Partly cloudy
      3: 'https://openweathermap.org/img/wn/04d@2x.png', // Overcast
      45: 'https://openweathermap.org/img/wn/50d@2x.png', // Foggy
      48: 'https://openweathermap.org/img/wn/50d@2x.png', // Depositing rime fog
      51: 'https://openweathermap.org/img/wn/09d@2x.png', // Light drizzle
      53: 'https://openweathermap.org/img/wn/09d@2x.png', // Moderate drizzle
      55: 'https://openweathermap.org/img/wn/09d@2x.png', // Dense drizzle
      61: 'https://openweathermap.org/img/wn/10d@2x.png', // Slight rain
      63: 'https://openweathermap.org/img/wn/10d@2x.png', // Moderate rain
      65: 'https://openweathermap.org/img/wn/10d@2x.png', // Heavy rain
      71: 'https://openweathermap.org/img/wn/13d@2x.png', // Slight snow
      73: 'https://openweathermap.org/img/wn/13d@2x.png', // Moderate snow
      75: 'https://openweathermap.org/img/wn/13d@2x.png', // Heavy snow
      77: 'https://openweathermap.org/img/wn/13d@2x.png', // Snow grains
      80: 'https://openweathermap.org/img/wn/09d@2x.png', // Slight rain showers
      81: 'https://openweathermap.org/img/wn/09d@2x.png', // Moderate rain showers
      82: 'https://openweathermap.org/img/wn/09d@2x.png', // Violent rain showers
      85: 'https://openweathermap.org/img/wn/13d@2x.png', // Slight snow showers
      86: 'https://openweathermap.org/img/wn/13d@2x.png', // Heavy snow showers
      95: 'https://openweathermap.org/img/wn/11d@2x.png', // Thunderstorm
      96: 'https://openweathermap.org/img/wn/11d@2x.png', // Thunderstorm with slight hail
      99: 'https://openweathermap.org/img/wn/11d@2x.png'  // Thunderstorm with heavy hail
    };

    // Function to get color based on temperature
    function getTemperatureColor(temp) {
  return temp > 35 ? '#800026' :  // Dark red
             temp > 30 ? '#E31A1C' :  // Bright red
             temp > 25 ? '#FD8D3C' :  // Orange
             temp > 20 ? '#FEB24C' :  // Light orange
             temp > 15 ? '#FED976' :  // Yellow
             temp > 10 ? '#BFDBF7' :  // Light blue
             temp > 5  ? '#6BAED6' :  // Medium blue
                        '#08519C';    // Dark blue  
                        }

    // Function to get color based on rainfall
    function getRainfallColor(rain) {
      if (rain <= 1) return '#E3F2FD';  // Very light blue
      if (rain <= 2) return '#90CAF9';  // Light blue
      if (rain <= 5) return '#2196F3';  // Medium blue
      if (rain <= 10) return '#1976D2'; // Dark blue
      return '#0D47A1';                 // Very dark blue
    }

    function initializeMap() {
 // Initialize map centered on Australia
      map = L.map('map').setView([-27, 133], 4);
      
      // Add the base tile layer
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
      }).addTo(map);

      // Add layer control buttons
      const layerControl = L.control({ position: 'topright' });
      layerControl.onAdd = function(map) {
        const div = L.DomUtil.create('div', 'layer-control');
          div.innerHTML = `
                     <div class="bg-white p-2 rounded shadow">
            <button id="tempLayer" class="px-3 py-1 bg-blue-500 text-white rounded mr-2">Temperature</button>
            <button id="rainLayer" class="px-3 py-1 bg-green-500 text-white rounded">Rainfall</button>
            </div>
          `;
         
        // Add click event listeners
        div.querySelector('#tempLayer').addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          switchLayer('temperature');
        });
        
        div.querySelector('#rainLayer').addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          switchLayer('rainfall');
        });

          return div;
      };
      layerControl.addTo(map);

      // Initialize markers for all cities
      Object.entries(cities_2).forEach(([city, [lat, lon]]) => {
        updateCityWeatherIcon(city, lat, lon);
      });

      // Load GeoJSON data and initialize the temperature layer
      fetch('./australia_states.geojson')
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then(data => {
          console.log('GeoJSON data loaded successfully');
          window.australianStates = data;
          updateChoroplethMap('temperature');
        })
        .catch(error => {
          console.error('Error loading GeoJSON:', error);
          alert('Error loading map data. Please try again later.');
        });
    }

    async function updateChoroplethMap(layerType) {
      if (!window.australianStates) {
        console.error('GeoJSON data not loaded yet');
        return;
      }
      
      currentLayer = layerType;
      console.log('Updating choropleth map for:', layerType);
      
      // Remove existing layers and legend if they exist
      if (temperatureLayer) map.removeLayer(temperatureLayer);
      if (rainfallLayer) map.removeLayer(rainfallLayer);
      if (window.currentLegend) map.removeControl(window.currentLegend);

      try {
        // Fetch current weather data for all capitals
        const weatherData = {};
        await Promise.all(Object.entries(cities_2).map(async ([city, [lat, lon]]) => {
          try {
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&daily=precipitation_sum&timezone=auto`;
            const res = await fetch(url);
            const data = await res.json();
            weatherData[city] = {
              temperature: data.current_weather.temperature,
              rainfall: data.daily.precipitation_sum[0] || 0
            };
          } catch (error) {
            console.error(`Error fetching data for ${city}:`, error);
          }
        }));

        // Create the choropleth layer
        const layer = L.geoJSON(window.australianStates, {
        style: function(feature) {
          const stateName = feature.properties.STATE_NAME.toLowerCase();
          let capitalCity;
          
          // Map state names to capital cities
          switch(stateName) {
            case 'victoria': capitalCity = 'melbourne'; break;
            case 'new south wales': capitalCity = 'sydney'; break;
            case 'queensland': capitalCity = 'brisbane'; break;
            case 'western australia': capitalCity = 'perth'; break;
            case 'south australia': capitalCity = 'adelaide'; break;
            case 'tasmania': capitalCity = 'hobart'; break;
            case 'northern territory': capitalCity = 'darwin'; break;
            case 'australian capital territory': capitalCity = 'canberra'; break;
            default: capitalCity = null;
          }

          const data = weatherData[capitalCity];
          if (!data) {
            return {
              fillColor: '#cccccc',
              color: '#666',
              weight: 2,
              opacity: 1,
              fillOpacity: 0.8
            };
          }

 const value = layerType === 'temperature' ? data.temperature : data.rainfall;
          const color = layerType === 'temperature' ? 
            getTemperatureColor(value) : 
            getRainfallColor(value);

          return {
            fillColor: color,
            color: '#ffffff',
            weight: 1,
            opacity: 0.5,
            fillOpacity: 0.8
          };
        },
          onEachFeature: function(feature, layer) {
            const stateName = feature.properties.STATE_NAME;
            const capitalName = stateName.toLowerCase();
            let capitalCity;
            
            switch(capitalName) {
              case 'victoria': capitalCity = 'melbourne'; break;
              case 'new south wales': capitalCity = 'sydney'; break;
              case 'queensland': capitalCity = 'brisbane'; break;
              case 'western australia': capitalCity = 'perth'; break;
              case 'south australia': capitalCity = 'adelaide'; break;
              case 'tasmania': capitalCity = 'hobart'; break;
              case 'northern territory': capitalCity = 'darwin'; break;
              case 'australian capital territory': capitalCity = 'canberra'; break;
              default: capitalCity = null;
            }
            
            const data = weatherData[capitalCity];
            
            if (data) {
              const displayValue = layerType === 'temperature' ? 
                formatTemperature(data.temperature) :
                `${data.rainfall.toFixed(1)} mm`;

              // Create tooltip content
              const tooltipContent = `
                <div style="font-size: 14px; line-height: 1.5;">
                  <strong>${stateName}</strong><br>
                  Capital: ${capitalCity.charAt(0).toUpperCase() + capitalCity.slice(1)}<br>
                  ${layerType.charAt(0).toUpperCase() + layerType.slice(1)}: ${displayValue}
                </div>
              `;

              // Add both popup and tooltip
              layer.bindPopup(tooltipContent);
              layer.bindTooltip(tooltipContent, {
                direction: 'center',
                permanent: false,
                sticky: true,
                opacity: 0.9,
                className: 'custom-tooltip'
              });
            }
          }
        }).addTo(map);

        // Store the layer reference
      if (layerType === 'temperature') {
          temperatureLayer = layer;
      } else {
        rainfallLayer = layer;
      }

  // Create and add the legend
      const legend = L.control({ position: 'bottomright' });
      legend.onAdd = function(map) {
        const div = L.DomUtil.create('div', 'legend');
                  div.style.backgroundColor = 'white';
          div.style.padding = '0';
          div.style.margin = '0';
          div.style.borderRadius = '4px';
          div.style.border = '1px solid rgba(0,0,0,0.2)';
          div.style.fontSize = '11px';
          div.style.lineHeight = '16px';
          div.style.maxWidth = '160px';
          div.style.maxHeight = '300px';
          div.style.overflowY = 'auto';
          div.style.marginBottom = '30px';
          div.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';

          let grades, title;
          if (layerType === 'temperature') {
            title = 'Temperature';
            grades = [
              { min: 35, max: null, color: '#800026', label: '> 35°C', desc: 'Very Hot' },
              { min: 30, max: 35, color: '#E31A1C', label: '30-35°C', desc: 'Hot' },
              { min: 25, max: 30, color: '#FD8D3C', label: '25-30°C', desc: 'Warm' },
              { min: 20, max: 25, color: '#FEB24C', label: '20-25°C', desc: 'Mild' },
              { min: 15, max: 20, color: '#FED976', label: '15-20°C', desc: 'Cool' },
              { min: 10, max: 15, color: '#BFDBF7', label: '10-15°C', desc: 'Cold' },
              { min: 5, max: 10, color: '#6BAED6', label: '5-10°C', desc: 'Very Cold' },
              { min: null, max: 5, color: '#08519C', label: '< 5°C', desc: 'Freezing' }
            ];
          } else {
            title = 'Rainfall';
            grades = [
              { min: 10, max: null, color: '#0D47A1', label: '> 10mm', desc: 'Heavy Rain' },
              { min: 5, max: 10, color: '#1976D2', label: '5-10mm', desc: 'Moderate Rain' },
              { min: 2, max: 5, color: '#2196F3', label: '2-5mm', desc: 'Light Rain' },
              { min: 1, max: 2, color: '#90CAF9', label: '1-2mm', desc: 'Very Light Rain' },
              { min: 0, max: 1, color: '#E3F2FD', label: '0-1mm', desc: 'Minimal Rain' }
            ];
          }

          div.innerHTML = `
            <div style="background-color: ${layerType === 'temperature' ? '#E31A1C' : '#1976D2'}; color: white; padding: 4px; border-top-left-radius: 3px; border-top-right-radius: 3px; font-weight: bold; font-size: 11px; text-align: center;">
              ${layerType === 'temperature' ? 'Temperature Legend' : 'Rainfall Legend'}
            </div>
            <div style="padding: 4px;">
              ${grades.map(grade => `
                <div style="display: flex; align-items: center; margin-bottom: 0px;">
                  <i style="
                    background: ${grade.color}; 
                    display: inline-block; 
                    width: 16px; 
                    height: 16px; 
                    margin-right: 4px; 
                    opacity: 0.9;
                    border: 1px solid rgba(0,0,0,0.2);
                    border-radius: 2px;
                  "></i>
                  <span style="flex-grow: 1;">
                    <strong style="font-size: 10px;">${grade.label}</strong>
                    <span style="color: #666; font-size: 9px; margin-left: 4px;">${grade.desc}</span>
                   </span>
                    </div>
              `).join('')}
            </div>
          `;

        return div;
      };

      // Store the legend reference and add it to the map
      window.currentLegend = legend;
      legend.addTo(map);

        // Update weather icons after choropleth is created
        Object.entries(cities_2).forEach(([city, [lat, lon]]) => {
          updateCityWeatherIcon(city, lat, lon);
        });

      } catch (error) {
        console.error('Error updating choropleth map:', error);
      }
    }

    function switchLayer(layerType) {
      if (currentLayer !== layerType) {
        updateChoroplethMap(layerType);
      }
    }

    // Function to create weather icon
    function createWeatherIcon(iconUrl, weatherCode) {
      return L.divIcon({
        html: `<img src="${iconUrl}" style="width: 30px; height: 30px;">`,
        className: 'weather-icon',
        iconSize: [30, 30],
        iconAnchor: [15, 15]
      });
    }

    // Define cities
    const cities = {
      melbourne: [-37.8136, 144.9631],
      sydney: [-33.8688, 151.2093],
      brisbane: [-27.4698, 153.0251],
      perth: [-31.9505, 115.8605],
      adelaide: [-34.9285, 138.6007],
      canberra: [-35.2809, 149.1300]
  
    };
    
    const cities_2 = {
      melbourne: [-37.8136, 144.9631],
      sydney: [-33.8688, 151.2093],
      brisbane: [-27.4698, 153.0251],
      perth: [-31.9505, 115.8605],
      adelaide: [-34.9285, 138.6007],
      hobart: [-42.8821, 147.3272],
      darwin: [-12.4634, 130.9277],
      canberra: [-35.2809, 149.1300]
  
    };

    // Initialize everything after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      initializeMap();
      initializeCharts();
      
      // Set up initial data
      const defaultCity = 'melbourne';
      const [lat, lon] = cities[defaultCity];
      loadCurrentWeather(lat, lon);
      
      // Load initial past weather data
      const currentYear = new Date().getFullYear() -1;
      const currentMonth = (new Date().getMonth() + 1).toString().padStart(2, '0');
      loadPastWeatherCompare('melbourne', 'sydney', currentYear, currentMonth);

      // Initialize year selectors with proper range
      const trendStartYear = document.getElementById('trendStartYear');
      const trendEndYear = document.getElementById('trendEndYear');
      const annualYearSelect = document.getElementById('annualYearSelect');

      // Clear existing options
      trendStartYear.innerHTML = '';
      trendEndYear.innerHTML = '';
      annualYearSelect.innerHTML = '';

      // Add options for the last 20 years, excluding future years
      for (let year = currentYear; year >= currentYear - 19; year--) {
        const opt1 = document.createElement('option');
        const opt2 = document.createElement('option');
        const opt3 = document.createElement('option');
        
        opt1.value = opt1.textContent = year;
        opt2.value = opt2.textContent = year;
        opt3.value = opt3.textContent = year;
        
        trendStartYear.appendChild(opt1);
        trendEndYear.appendChild(opt2);
        annualYearSelect.appendChild(opt3);
      }

      // Set default selections
      trendStartYear.value = currentYear - 19;
      trendEndYear.value = currentYear;
      annualYearSelect.value = currentYear;

      // Initialize the new charts with data
      updateAnnualPattern();
      updateExtremesAndRainfall();
      updateTrendAnalysis();

      // Add event listeners for the new selectors
      document.getElementById('annualCitySelect').addEventListener('change', () => {
        updateAnnualPattern();
        updateExtremesAndRainfall();
      });
      document.getElementById('annualYearSelect').addEventListener('change', () => {
        updateAnnualPattern();
        updateExtremesAndRainfall();
      });
      document.getElementById('trendCitySelect').addEventListener('change', updateTrendAnalysis);
      document.getElementById('trendStartYear').addEventListener('change', updateTrendAnalysis);
      document.getElementById('trendEndYear').addEventListener('change', updateTrendAnalysis);

      // Update city select options
      const citySelects = [
        'currentCitySelect',
        'pastCitySelectA',
        'pastCitySelectB',
        'annualCitySelect',
        'trendCitySelect'
      ];

      citySelects.forEach(selectId => {
        const select = document.getElementById(selectId);
        if (select) {
          select.innerHTML = ''; // Clear existing options
          Object.keys(cities).forEach(city => {
            const option = document.createElement('option');
            option.value = city;
            option.textContent = city.charAt(0).toUpperCase() + city.slice(1);
            select.appendChild(option);
          });
        }
      });

      // Set default selections
      document.getElementById('currentCitySelect').value = 'melbourne';
      document.getElementById('pastCitySelectA').value = 'melbourne';
      document.getElementById('pastCitySelectB').value = 'sydney';
      document.getElementById('annualCitySelect').value = 'melbourne';
      document.getElementById('trendCitySelect').value = 'melbourne';

      updateForecastChart(); // Add this line to initialize the forecast chart
    });

    function initializeCharts() {
      // Initialize forecast chart
      const forecastCtx = document.getElementById('forecastChart').getContext('2d');
      forecastChart = new Chart(forecastCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'City A Max',
              data: [],
              borderColor: 'rgb(255, 99, 132)',
              backgroundColor: 'rgb(255, 99, 132)',
              fill: false,
              tension: 0.4,
              borderWidth: 2,
              pointRadius: 3,
              pointHoverRadius: 5,
              pointStyle: 'circle'
            },
            {
              label: 'City A Min',
              data: [],
              borderColor: 'rgb(255, 159, 64)',
              backgroundColor: 'rgb(255, 159, 64)',
              fill: false,
              tension: 0.4,
              borderWidth: 2,
              pointRadius: 3,
              pointHoverRadius: 5,
              pointStyle: 'circle'
            },
            {
              label: 'City B Max',
              data: [],
              borderColor: 'rgb(75, 192, 192)',
              backgroundColor: 'rgb(75, 192, 192)',
              fill: false,
              tension: 0.4,
              borderWidth: 2,
              pointRadius: 3,
              pointHoverRadius: 5,
              pointStyle: 'circle'
            },
            {
              label: 'City B Min',
              data: [],
              borderColor: 'rgb(54, 162, 235)',
              backgroundColor: 'rgb(54, 162, 235)',
              fill: false,
              tension: 0.4,
              borderWidth: 2,
              pointRadius: 3,
              pointHoverRadius: 5,
              pointStyle: 'circle'
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            title: {
              display: true,
              text: '7-Day Temperature Forecast Comparison',
              color: 'white',
              font: { size: 16, weight: 'bold' }
            },
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: 'white',
                usePointStyle: true,
                pointStyle: 'circle',
                font: { size: 12 }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const temp = context.raw;
                  return `${context.dataset.label}: ${useMetric ? temp.toFixed(1) + '°C' : celsiusToFahrenheit(temp).toFixed(1) + '°F'}`;
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Date',
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 },
                callback: function(value, index) {
                  const date = new Date(this.getLabelForValue(value));
                  return date.toLocaleDateString('en-AU', { weekday: 'short', month: 'short', day: 'numeric' });
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            },
            y: {
              title: {
                display: true,
                text: useMetric ? 'Temperature (°C)' : 'Temperature (°F)',
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 },
                callback: function(value) {
                  return useMetric ? value + '°C' : celsiusToFahrenheit(value).toFixed(1) + '°F';
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            }
          }
        }
      });

      // Initialize temperature comparison chart
      const tempCtx = document.getElementById('tempChart').getContext('2d');
      tempChart = new Chart(tempCtx, {
        type: 'line',
        data: { 
          labels: [], 
          datasets: [
            { 
              label: 'City A',
              data: [],
              borderColor: 'rgb(255, 99, 132)',
              backgroundColor: 'rgba(255, 99, 132, 0.2)',
              fill: true,
              tension: 0.4,
              pointHitRadius: 10
            },
            { 
              label: 'City B',
              data: [],
              borderColor: 'rgb(75, 192, 192)',
              backgroundColor: 'rgba(75, 192, 192, 0.2)',
              fill: true,
              tension: 0.4,
              pointHitRadius: 10
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: 'Daily Temperature Comparison',
              color: 'white',
              font: { size: 16, weight: 'bold' }
            },
            legend: {
              display: true,
              position: 'top',
              labels: { 
                color: 'white',
                usePointStyle: true,
                pointStyle: 'circle',
                font: { size: 12 }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const temp = context.raw;
                  return `${context.dataset.label}: ${useMetric ? temp.toFixed(1) + '°C' : celsiusToFahrenheit(temp).toFixed(1) + '°F'}`;
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Date',
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 },
                callback: function(value, index) {
                  const date = new Date(this.getLabelForValue(value));
                  return date.toLocaleDateString('en-AU', { day: 'numeric' });
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            },
            y: {
              title: {
                display: true,
                text: useMetric ? 'Temperature (°C)' : 'Temperature (°F)',
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 },
                callback: function(value) {
                  return useMetric ? value + '°C' : celsiusToFahrenheit(value).toFixed(1) + '°F';
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            }
          }
        }
      });

      // Initialize rainfall chart
      const rainCtx = document.getElementById('rainChart').getContext('2d');
      rainChart = new Chart(rainCtx, {
        type: 'bar',
        data: { 
          labels: [], 
          datasets: [
            {
              label: 'City A',
              data: [],
              backgroundColor: 'rgba(54, 162, 235, 0.6)',
              borderColor: 'rgb(54, 162, 235)',
              borderWidth: 1
            },
            {
              label: 'City B',
              data: [],
              backgroundColor: 'rgba(75, 192, 192, 0.6)',
              borderColor: 'rgb(75, 192, 192)',
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: 'Daily Rainfall Comparison',
              color: 'white',
              font: { size: 16, weight: 'bold' }
            },
            legend: {
              display: true,
              position: 'top',
              labels: { 
                color: 'white',
                usePointStyle: true,
                pointStyle: 'rect',
                font: { size: 12 }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${context.dataset.label}: ${context.raw.toFixed(1)} mm`;
                },
                footer: function(tooltipItems) {
                  const dataIndex = tooltipItems[0].dataIndex;
                  const datasets = tooltipItems[0].chart.data.datasets;
                  const total = datasets.reduce((sum, dataset) => sum + (dataset.data[dataIndex] || 0), 0);
                  return `Total rainfall: ${total.toFixed(1)} mm`;
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Date',
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 },
                callback: function(value, index) {
                  const date = new Date(this.getLabelForValue(value));
                  return date.toLocaleDateString('en-AU', { day: 'numeric' });
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            },
            y: {
              title: {
                display: true,
                text: 'Rainfall (mm)',
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 },
                callback: function(value) {
                  return value + ' mm';
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            }
          }
        }
      });

      // Initialize Annual Pattern Chart with click interaction
      const annualPatternCtx = document.getElementById('annualPatternChart').getContext('2d');
      annualPatternChart = new Chart(annualPatternCtx, {
        type: 'line',
        data: {
          labels: Array.from({length: 12}, (_, i) => new Date(2024, i).toLocaleString('default', { month: 'long' })),
          datasets: [
            {
              label: 'Max Temperature',
              borderColor: 'rgb(255, 99, 132)',
              backgroundColor: 'rgba(255, 99, 132, 0.2)',
              fill: true,
              tension: 0.4,
              pointHitRadius: 10
            },
            {
              label: 'Min Temperature',
              borderColor: 'rgb(54, 162, 235)',
              backgroundColor: 'rgba(54, 162, 235, 0.2)',
              fill: true,
              tension: 0.4,
              pointHitRadius: 10
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: { 
              display: true, 
              text: 'Monthly Temperature Pattern',
              color: 'white',
              font: { size: 16, weight: 'bold' }
            },
            legend: {
              display: true,
              position: 'top',
              labels: { 
                color: 'white',
                usePointStyle: true,
                pointStyle: 'circle',
                font: { size: 12 }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const temp = context.raw;
                  return `${context.dataset.label}: ${useMetric ? temp.toFixed(1) + '°C' : celsiusToFahrenheit(temp).toFixed(1) + '°F'}`;
                }
              }
            }
          },
          scales: {
            x: {
              title: { 
                display: true, 
                text: 'Month', 
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            },
            y: {
              title: { 
                display: true, 
                text: useMetric ? 'Temperature (°C)' : 'Temperature (°F)', 
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 },
                callback: function(value) {
                  return useMetric ? value + '°C' : celsiusToFahrenheit(value).toFixed(1) + '°F';
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            }
          }
        }
      });

      // Initialize Extremes Chart
      const extremesCtx = document.getElementById('extremesChart').getContext('2d');
      extremesChart = new Chart(extremesCtx, {
        type: 'bar',
        data: {
          labels: ['Summer', 'Autumn', 'Winter', 'Spring'],
          datasets: [
            {
              label: 'Record High',
              backgroundColor: 'rgba(255, 99, 132, 0.5)',
              borderColor: 'rgb(255, 99, 132)',
              borderWidth: 1
            },
            {
              label: 'Record Low',
              backgroundColor: 'rgba(54, 162, 235, 0.5)',
              borderColor: 'rgb(54, 162, 235)',
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: { 
              display: true, 
              text: 'Seasonal Temperature Extremes', 
              color: 'white',
              font: { size: 16, weight: 'bold' }
            },
            legend: {
              display: true,
              position: 'top',
              labels: { 
                color: 'white',
                usePointStyle: true,
                pointStyle: 'rect',
                font: { size: 12 }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const temp = context.raw;
                  return `${context.dataset.label}: ${useMetric ? temp.toFixed(1) + '°C' : celsiusToFahrenheit(temp).toFixed(1) + '°F'}`;
                }
              }
            }
          },
          scales: {
            x: { 
              title: {
                display: true,
                text: 'Season',
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            },
            y: { 
              title: {
                display: true,
                text: useMetric ? 'Temperature (°C)' : 'Temperature (°F)',
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 },
                callback: function(value) {
                  return useMetric ? value + '°C' : celsiusToFahrenheit(value).toFixed(1) + '°F';
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            }
          }
        }
      });

      // Initialize Monthly Rain Chart
      const monthlyRainCtx = document.getElementById('monthlyRainChart').getContext('2d');
      monthlyRainChart = new Chart(monthlyRainCtx, {
        type: 'bar',
        data: {
          labels: Array.from({length: 12}, (_, i) => new Date(2024, i).toLocaleString('default', { month: 'short' })),
          datasets: [{
            label: 'Average Rainfall',
            backgroundColor: 'rgba(54, 162, 235, 0.5)',
            borderColor: 'rgb(54, 162, 235)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            title: { 
              display: true, 
              text: 'Monthly Rainfall Distribution', 
              color: 'white',
              font: { size: 16, weight: 'bold' }
            },
            legend: {
              display: true,
              position: 'top',
              labels: { 
                color: 'white',
                usePointStyle: true,
                pointStyle: 'rect',
                font: { size: 12 }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Rainfall: ${context.raw.toFixed(1)} mm`;
                }
              }
            }
          },
          scales: {
            x: { 
              title: {
                display: true,
                text: 'Month',
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            },
            y: { 
              title: {
                display: true,
                text: 'Rainfall (mm)',
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 },
                callback: function(value) {
                  return value + ' mm';
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            }
          }
        }
      });

      // Initialize Trend Chart
      const trendCtx = document.getElementById('trendChart').getContext('2d');
      trendChart = new Chart(trendCtx, {
        type: 'line',
        data: {
          datasets: [{
            label: 'Average Temperature',
            borderColor: 'rgb(255, 99, 132)',
            backgroundColor: 'rgba(255, 99, 132, 0.1)',
            fill: true,
            tension: 0.4,
            pointHitRadius: 10
          }]
        },
        options: {
          responsive: true,
          plugins: {
            title: { 
              display: true, 
              text: 'Long-term Temperature Trend', 
              color: 'white',
              font: { size: 16, weight: 'bold' }
            },
            legend: {
              display: true,
              position: 'top',
              labels: { 
                color: 'white',
                usePointStyle: true,
                pointStyle: 'circle',
                font: { size: 12 }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const temp = context.raw;
                  return `${context.dataset.label}: ${useMetric ? temp.toFixed(1) + '°C' : celsiusToFahrenheit(temp).toFixed(1) + '°F'}`;
                }
              }
            }
          },
          scales: {
            x: { 
              title: {
                display: true,
                text: 'Year',
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            },
            y: { 
              title: {
                display: true,
                text: useMetric ? 'Temperature (°C)' : 'Temperature (°F)',
                color: 'white',
                font: { size: 12, weight: 'bold' }
              },
              ticks: { 
                color: 'white',
                font: { size: 11 },
                callback: function(value) {
                  return useMetric ? value + '°C' : celsiusToFahrenheit(value).toFixed(1) + '°F';
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            }
          }
        }
      });
    }

    function locateUser() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;
            map.setView([lat, lon], 10);
            
            // Remove existing user marker if it exists
            if (currentMarker) {
              map.removeLayer(currentMarker);
            }
            
            // Create a special marker for user location
            currentMarker = L.marker([lat, lon], {
              icon: L.divIcon({
                html: '📍',
                className: 'user-location',
                iconSize: [25, 25],
                iconAnchor: [12, 24]
              })
            })
              .addTo(map)
              .bindPopup("Your Location")
              .openPopup();
            
            loadCurrentWeather(lat, lon);
          },
          () => {
            alert("Unable to retrieve your location. Using default city.");
            const [lat, lon] = cities['melbourne'];
            map.setView([lat, lon], 10);
            loadCurrentWeather(lat, lon);
          }
        );
      } else {
        alert("Geolocation not supported.");
      }
    }
    
    // Update forecast chart function
    async function updateForecastChart() {
      const cityA = document.getElementById('forecastCityA').value;
      const cityB = document.getElementById('forecastCityB').value;
      
      try {
        // Fetch data for both cities
        const [cityAData, cityBData] = await Promise.all([
          fetch(`https://api.open-meteo.com/v1/forecast?latitude=${cities[cityA][0]}&longitude=${cities[cityA][1]}&daily=temperature_2m_max,temperature_2m_min&timezone=auto`).then(res => res.json()),
          fetch(`https://api.open-meteo.com/v1/forecast?latitude=${cities[cityB][0]}&longitude=${cities[cityB][1]}&daily=temperature_2m_max,temperature_2m_min&timezone=auto`).then(res => res.json())
        ]);

        if (!cityAData.daily || !cityBData.daily) {
          console.error('Invalid forecast data received');
          return;
        }

        const maxTempsA = cityAData.daily.temperature_2m_max.map(temp => useMetric ? temp : celsiusToFahrenheit(temp));
        const minTempsA = cityAData.daily.temperature_2m_min.map(temp => useMetric ? temp : celsiusToFahrenheit(temp));
        const maxTempsB = cityBData.daily.temperature_2m_max.map(temp => useMetric ? temp : celsiusToFahrenheit(temp));
        const minTempsB = cityBData.daily.temperature_2m_min.map(temp => useMetric ? temp : celsiusToFahrenheit(temp));

        // Update chart data
        forecastChart.data.labels = cityAData.daily.time;
        forecastChart.data.datasets[0].data = maxTempsA;
        forecastChart.data.datasets[1].data = minTempsA;
        forecastChart.data.datasets[2].data = maxTempsB;
        forecastChart.data.datasets[3].data = minTempsB;

        // Update dataset labels
        forecastChart.data.datasets[0].label = `${cityA.charAt(0).toUpperCase() + cityA.slice(1)} Max`;
        forecastChart.data.datasets[1].label = `${cityA.charAt(0).toUpperCase() + cityA.slice(1)} Min`;
        forecastChart.data.datasets[2].label = `${cityB.charAt(0).toUpperCase() + cityB.slice(1)} Max`;
        forecastChart.data.datasets[3].label = `${cityB.charAt(0).toUpperCase() + cityB.slice(1)} Min`;

        // Clear existing annotations
        forecastChart.options.plugins.annotation.annotations = {};

        // Add temperature labels for each data point
        [maxTempsA, minTempsA, maxTempsB, minTempsB].forEach((temps, datasetIndex) => {
          temps.forEach((temp, index) => {
            forecastChart.options.plugins.annotation.annotations[`temp-${datasetIndex}-${index}`] = {
              type: 'point',
              xValue: index,
              yValue: temp,
              backgroundColor: 'transparent',
              borderColor: 'transparent',
              label: {
                enabled: true,
                content: useMetric ? `${temp.toFixed(1)}°C` : `${temp.toFixed(1)}°F`,
                position: datasetIndex % 2 === 0 ? 'top' : 'bottom',
                yAdjust: datasetIndex % 2 === 0 ? -10 : 10,
                color: 'white',
                backgroundColor: forecastChart.data.datasets[datasetIndex].backgroundColor
              }
            };
          });
        });

        forecastChart.options.scales.y.title.text = useMetric ? 'Temperature (°C)' : 'Temperature (°F)';
        forecastChart.update('none');
      } catch (error) {
        console.error('Error updating forecast chart:', error);
      }
    }

    // Function to update weather icon for a city
    async function updateCityWeatherIcon(city, lat, lon) {
      try {
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&timezone=auto`;
        const res = await fetch(url);
        const data = await res.json();
        const weatherCode = data.current_weather.weathercode;
        const iconUrl = weatherIcons[weatherCode] || weatherIcons[0];

        if (cityMarkers[city]) {
          map.removeLayer(cityMarkers[city]);
        }

        cityMarkers[city] = L.marker([lat, lon], {
          icon: createWeatherIcon(iconUrl, weatherCode)
        })
          .addTo(map)
          .bindPopup(
            `${city.charAt(0).toUpperCase() + city.slice(1)}<br>` +
            `Temperature: ${formatTemperature(data.current_weather.temperature)}<br>` +
            `Wind: ${formatWindSpeed(data.current_weather.windspeed)}`
          );
      } catch (error) {
        console.error(`Error updating weather icon for ${city}:`, error);
      }
    }

    // Conversion functions
    function celsiusToFahrenheit(celsius) {
      return (celsius * 9/5) + 32;
    }

    function fahrenheitToCelsius(fahrenheit) {
      return (fahrenheit - 32) * 5/9;
    }

    function kmhToMph(kmh) {
      return kmh * 0.621371;
    }

    function mphToKmh(mph) {
      return mph / 0.621371;
    }

    function formatTemperature(celsius) {
      if (useMetric) {
        return `${celsius.toFixed(1)}°C`;
      }
      return `${celsiusToFahrenheit(celsius).toFixed(1)}°F`;
    }

    function formatWindSpeed(kmh) {
      if (useMetric) {
        return `${kmh.toFixed(1)} km/h`;
      }
      return `${kmhToMph(kmh).toFixed(1)} mph`;
    }

    function toggleUnits() {
      useMetric = !useMetric;
      
      // Update toggle switch and label
      const unitLabel = document.getElementById('unitLabel');
      unitLabel.textContent = useMetric ? 'Metric (°C)' : 'Imperial (°F)';
      
      // Update all weather cards
      const weatherElements = document.querySelectorAll('[data-weather]');
      weatherElements.forEach(element => {
        const type = element.getAttribute('data-weather');
        const value = parseFloat(element.getAttribute('data-value'));
        
        if (type === 'temperature') {
          const temp = useMetric ? value : celsiusToFahrenheit(value);
          element.innerHTML = `${temp.toFixed(1)}<span class="weather-unit">${useMetric ? '°C' : '°F'}</span>`;
        } else if (type === 'wind') {
          const speed = useMetric ? value : kmhToMph(value);
          element.innerHTML = `${speed.toFixed(1)}<span class="weather-unit">${useMetric ? 'km/h' : 'mph'}</span>`;
        }
      });

      // Refresh current weather display
      const [lat, lon] = cities[document.getElementById('currentCitySelect').value];
      loadCurrentWeather(lat, lon);
      
      // Update all charts if they exist
      if (forecastChart) updateForecastChart();
      if (tempChart) updatePastWeather();
      if (annualPatternChart) updateAnnualPattern();
      if (extremesChart) updateExtremesAndRainfall();
      if (trendChart) updateTrendAnalysis();
    }

    function showSection(name) {
      // Hide all sections
      document.getElementById("current").classList.add("hidden");
      document.getElementById("past").classList.add("hidden");
      document.getElementById("map-section").classList.add("hidden");
      document.getElementById("settings").classList.add("hidden");
      
      // Show the selected section
      if (name === 'map') {
        document.getElementById("map-section").classList.remove("hidden");
        // Trigger a resize event to ensure the map renders correctly
        if (map) {
          setTimeout(() => {
            map.invalidateSize();
          }, 100);
        }
      } else {
      document.getElementById(name).classList.remove("hidden");
      }
      
      // Update active state for navigation links
      const navLinks = document.querySelectorAll('.nav-link');
      navLinks.forEach(link => {
        link.classList.remove('active');
        if (link.textContent.trim().toLowerCase().includes(name)) {
          link.classList.add('active');
        }
      });
    }

    function windDirection(deg) {
      const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      return directions[Math.round(deg / 45) % 8];
    }

    // use BOM to retrieve the most recent data
    async function loadCurrentWeather(lat, lon) {
      try {
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,weathercode,sunrise,sunset&hourly=temperature_2m,relativehumidity_2m,visibility,pressure_msl,uv_index&timezone=auto`;
        const res = await fetch(url);
        const data = await res.json();

        const current = data.current_weather;
        const daily = data.daily;
        const hourly = data.hourly;

        // Get current hour index
        const currentTime = new Date();
        const currentHourIndex = currentTime.getHours();

        // Calculate sun progress
        const sunrise = new Date(daily.sunrise[0]);
        const sunset = new Date(daily.sunset[0]);
        const totalDayLength = sunset - sunrise;
        const currentProgress = Math.max(0, Math.min(100, ((currentTime - sunrise) / totalDayLength) * 100));

        const cards = document.getElementById("cards");
        cards.className = "grid-container"; // Add this line to use the new grid layout
        cards.innerHTML = '';

        // Temperature with feels like
        cards.innerHTML += createCard(
          "Temperature",
          current.temperature,
          "🌡️",
          "temperature",
          { type: 'feels-like', value: hourly.temperature_2m[currentHourIndex] }
        );

        // Wind with direction
        cards.innerHTML += createCard(
          "Wind",
           current.windspeed,
          "💨",
          "wind",
          { type: 'direction', value: windDirection(current.winddirection) }
        );

        // Humidity with simple percentage
        cards.innerHTML += createCard(
          "Humidity",
          hourly.relativehumidity_2m[currentHourIndex],
          "💧",
          "humidity",
          null  // Remove the circular progress by passing null instead of the progress object
        );

        // UV Index with color indicator
        const uvIndex = hourly.uv_index[currentHourIndex];
        const uvLabel = getUVLabel(uvIndex);
        cards.innerHTML += createCard(
          "UV Index",
          uvIndex.toFixed(1),
          "🔆",
          "uv",
          { type: 'uv-index', value: uvIndex, label: uvLabel }
        );

        // Visibility (👁️ eye symbol)
cards.innerHTML += createCard(
  "Visibility",
  (hourly.visibility[currentHourIndex] / 1000).toFixed(1) + " km",
  "👁️",
  "visibility",
  {} // ensure this is passed, even if unused
);

// Air Pressure (📊 or 🧭 or 🎚️ also works)
cards.innerHTML += createCard(
  "Pressure",
  hourly.pressure_msl[currentHourIndex].toFixed(0) + " hPa",
  "📊",
  "pressure",
  {}
);

        // Sun Progress
        cards.innerHTML += createCard(
          "Daylight",
          formatTime(sunrise) + " - " + formatTime(sunset),
          "🌅",
          "sun",
          {
            type: 'sun-progress',
            sunrise: formatTime(sunrise),
            sunset: formatTime(sunset),
            progress: currentProgress
          }
        );

        // Rain
cards.innerHTML += createCard(
  "Rain",
  daily.precipitation_sum[0] + " mm",
  "☔",
  "rain",
  {}
);

      } catch (error) {
        console.error("Error loading current weather:", error);
      }
    }

    function formatTime(date) {
      return date.toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', hour12: true });
    }

    function getUVLabel(index) {
      if (index <= 2) return 'Low';
      if (index <= 5) return 'Moderate';
      if (index <= 7) return 'High';
      if (index <= 10) return 'Very High';
      return 'Extreme';
    }

    async function loadPastWeatherCompare(cityA, cityB, year, month) {
  const start = `${year}-${month}-01`;
  const end = `${year}-${month}-${new Date(year, month, 0).getDate()}`;

try {
        // Capitalize city names for the API call
        const response = await fetch(`http://127.0.0.1:5000/weather/raw?city=${cityA.charAt(0).toUpperCase() + cityA.slice(1)}&city=${cityB.charAt(0).toUpperCase() + cityB.slice(1)}`);
        const data = await response.json();

        console.log("API Response:", data); // Debugging log

        // Capitalize city names for accessing the data object
        const cityAKey = cityA.charAt(0).toUpperCase() + cityA.slice(1);
        const cityBKey = cityB.charAt(0).toUpperCase() + cityB.slice(1);

        // Check if data exists for the cities
        if (!data[cityAKey] || !data[cityBKey]) {
          console.error("No data available for the selected cities.");
          return;
        }

        // Filter data for the selected month
        const cityAData = data[cityAKey].filter(record => record.date >= start && record.date <= end);
        const cityBData = data[cityBKey].filter(record => record.date >= start && record.date <= end);

        console.log("City A Data:", cityAData); // Debugging log
        console.log("City B Data:", cityBData); // Debugging log

      // Update temperature chart
        tempChart.data.labels = cityAData.map(record => record.date);
        tempChart.data.datasets[0].label = cityAKey;
        tempChart.data.datasets[1].label = cityBKey;
        tempChart.data.datasets[0].data = cityAData.map(record => record.temperature_2m_max);
        tempChart.data.datasets[1].data = cityBData.map(record => record.temperature_2m_max);

  tempChart.update();

  // Update rainfall chart
        rainChart.data.labels = cityAData.map(record => record.date);
        rainChart.data.datasets[0].label = cityAKey;
        rainChart.data.datasets[1].label = cityBKey;
        rainChart.data.datasets[0].data = cityAData.map(record => record.precipitation_sum);
        rainChart.data.datasets[1].data = cityBData.map(record => record.precipitation_sum);

        rainChart.update();
      } catch (error) {
        console.error("Error loading past weather data:", error);
      }
    }

function updatePastWeather() {
  const cityA = document.getElementById("pastCitySelectA").value;
  const cityB = document.getElementById("pastCitySelectB").value;
  const year = document.getElementById("yearSelect").value;
  const month = document.getElementById("monthSelect").value;
  loadPastWeatherCompare(cityA, cityB, year, month);
}

    function createCard(title, value, icon = '', type = '', extraInfo = null) {
      let displayValue = value;
      let originalValue = '';
      let extraContent = '';
      let unitText = '';
      let description = getWeatherDescription(type, value);
      
      if (type === 'temperature') {
        originalValue = parseFloat(value);
        displayValue = useMetric ? originalValue.toFixed(1) : celsiusToFahrenheit(originalValue).toFixed(1);
        unitText = useMetric ? '°C' : '°F';
      } else if (type === 'wind') {
        originalValue = parseFloat(value);
        displayValue = useMetric ? originalValue.toFixed(1) : kmhToMph(originalValue).toFixed(1);
        unitText = useMetric ? 'km/h' : 'mph';
      } else if (type === 'humidity') {
        displayValue = parseFloat(value).toFixed(0);
        unitText = '%';
      } else if (type === 'visibility') {
        displayValue = parseFloat(value).toFixed(1);
        unitText = 'km';
      } else if (type === 'pressure') {
        displayValue = parseFloat(value).toFixed(0);
        unitText = 'hPa';
      } else if (type === 'rain') {
        displayValue = parseFloat(value).toFixed(1);
        unitText = 'mm';
      }

      // Add extra information if provided
      if (extraInfo) {
        if (extraInfo.type === 'sun-progress') {
          extraContent = `
            <div class="mt-4">
              <div class="time-range">
                <span>${extraInfo.sunrise}</span>
                <span>${extraInfo.sunset}</span>
              </div>
              <div class="sun-progress">
                <div class="sun-indicator" style="left: ${extraInfo.progress}%"></div>
              </div>
            </div>
          `;
        } else if (extraInfo.type === 'uv-index') {
          extraContent = `
            <div class="uv-indicator">
              <div class="uv-marker" style="margin-left: ${extraInfo.value * 10}%"></div>
            </div>
            <div class="uv-label">${extraInfo.label}</div>
          `;
        }
      }

      return `
        <div class="weather-card rounded-lg p-4 fade-in">
          <div class="weather-content">
            <div class="flex items-center justify-between">
              <h2 class="weather-title">${title}</h2>
              <i class="weather-icon fas ${getIconClass(type)}" style="color: #60a5fa;"></i>
          </div>
            <div class="weather-info text-center">
              <div class="weather-value" data-weather="${type}" data-value="${originalValue}">
                ${displayValue}<span class="weather-unit">${unitText}</span>
              </div>
              ${extraContent}
              <div class="weather-description">${description}</div>
            </div>
          </div>
        </div>
      `;
    }

    function getIconClass(type) {
      switch(type) {
  case 'temperature': return 'fa-temperature-three-quarters'; // better than fa-temperature-high
  case 'wind': return 'fa-wind';
  case 'humidity': return 'fa-droplet'; // cleaner in FA6
  case 'uv': return 'fa-circle-radiation'; // NEW for UV (distinct from sun)
  case 'visibility': return 'fa-eye';
  case 'pressure': return 'fa-gauge-high'; // replaces tachometer-alt in FA6
  case 'sun': return 'fa-sun-plant-wilt'; // more metaphorical for daylight span
  case 'rain': return 'fa-cloud-rain'; // simpler than fa-cloud-showers-heavy
  default: return 'fa-circle';
}
    }

    function getWeatherDescription(type, value) {
      switch(type) {
        case 'temperature':
          const temp = parseFloat(value);
          if (temp > 30) return 'Very hot conditions';
          if (temp > 25) return 'Warm conditions';
          if (temp > 20) return 'Mild conditions';
          if (temp > 15) return 'Cool conditions';
          return 'Cold conditions';
        case 'wind':
          const wind = parseFloat(value);
          if (wind > 50) return 'Strong winds';
          if (wind > 30) return 'Moderate winds';
          return 'Light breeze';
        case 'humidity':
          const humidity = parseFloat(value);
          if (humidity > 70) return 'Very humid';
          if (humidity > 50) return 'Moderately humid';
          return 'Comfortable humidity';
        case 'uv':
          const uv = parseFloat(value);
          if (uv > 8) return 'Very high UV exposure';
          if (uv > 5) return 'High UV exposure';
          if (uv > 2) return 'Moderate UV exposure';
          return 'Low UV exposure';
        case 'visibility':
          const vis = parseFloat(value);
          if (vis > 20) return 'Excellent visibility';
          if (vis > 10) return 'Good visibility';
          return 'Limited visibility';
        case 'pressure':
          const pressure = parseFloat(value);
          if (pressure > 1013) return 'High pressure system';
          if (pressure < 1013) return 'Low pressure system';
          return 'Normal atmospheric pressure';
        case 'sun':
          return 'Daylight hours and sun position';
        case 'rain':
          const rain = parseFloat(value);
          if (rain > 10) return 'Heavy rainfall';
          if (rain > 5) return 'Moderate rainfall';
          if (rain > 0) return 'Light rainfall';
          return 'No rainfall';
        default:
          return '';
      }
    }

    document.getElementById("currentCitySelect").addEventListener("change", (e) => {
      const city = e.target.value;
      const [lat, lon] = cities[city];
      
      // Remove existing marker
      if (currentMarker) {
        map.removeLayer(currentMarker);
      }
      
      // Add new marker and center map
      map.setView([lat, lon], 7);
      currentMarker = L.marker([lat, lon])
        .addTo(map)
        .bindPopup(city.charAt(0).toUpperCase() + city.slice(1))
        .openPopup();
      
      // Load current weather for the selected city
      loadCurrentWeather(lat, lon);
    });

    // Add event listeners to automatically apply past weather selection
    document.getElementById("pastCitySelectA").addEventListener("change", updatePastWeather);
    document.getElementById("pastCitySelectB").addEventListener("change", updatePastWeather);
    document.getElementById("yearSelect").addEventListener("change", updatePastWeather);
    document.getElementById("monthSelect").addEventListener("change", updatePastWeather);

    const now = new Date().getFullYear();
    const yearSel = document.getElementById("yearSelect");
    for (let y = now; y >= now - 20; y--) {
      const opt = document.createElement("option");
      opt.value = y;
      opt.textContent = y;
      yearSel.appendChild(opt);
    }

    // Initial load for Melbourne and past weather
    loadCurrentWeather(...cities['melbourne']);
    updatePastWeather();

    // Add new update functions for the charts
    async function updateAnnualPattern() {
      const city = document.getElementById('annualCitySelect').value;
      const year = document.getElementById('annualYearSelect').value;
    
      try {
               // Fetch data from the backend
        const response = await fetch(`http://127.0.0.1:5000/weather/raw?city=${city.charAt(0).toUpperCase() + city.slice(1)}`);
        const data = await response.json();

        const cityKey = city.charAt(0).toUpperCase() + city.slice(1);
        const cityData = data[cityKey].filter(record => record.date.startsWith(year));

        // Process data into monthly averages
        const monthlyData = Array(12).fill().map(() => ({ max: [], min: [] }));
        cityData.forEach(record => {
          const month = new Date(record.date).getMonth();
          monthlyData[month].max.push(record.temperature_2m_max);
          monthlyData[month].min.push(record.temperature_2m_min); 
        });

        // Calculate monthly averages
        const monthlyAverages = monthlyData.map(month => ({
          max: month.max.length > 0 ? month.max.reduce((a, b) => a + b, 0) / month.max.length : null,
          min: month.min.length > 0 ? month.min.reduce((a, b) => a + b, 0) / month.min.length : null
        }));

        // Update chart
        annualPatternChart.data.datasets[0].data = monthlyAverages.map(m => 
          m.max !== null ? (useMetric ? m.max : celsiusToFahrenheit(m.max)) : null
        );
        annualPatternChart.data.datasets[1].data = monthlyAverages.map(m => 
          m.min !== null ? (useMetric ? m.min : celsiusToFahrenheit(m.min)) : null
        );

        annualPatternChart.update();
      } catch (error) {
        console.error('Error updating annual pattern:', error);
      }
    }

    async function updateTrendAnalysis() {
      const city = document.getElementById('trendCitySelect').value;
      const startYear = parseInt(document.getElementById('trendStartYear').value);
      const endYear = parseInt(document.getElementById('trendEndYear').value);
      
      try {
        // Fetch data from the backend
        const response = await fetch(`http://127.0.0.1:5000/weather/raw?city=${city.charAt(0).toUpperCase() + city.slice(1)}`);
        const data = await response.json();
        
        const cityKey = city.charAt(0).toUpperCase() + city.slice(1);
        const cityData = data[cityKey];

        if (!cityData) {
          console.error('No data available for', cityKey);
          return;
        }

        // Process data into yearly averages
        const yearlyData = {};
        cityData.forEach(record => {
          const year = parseInt(record.date.split('-')[0]);
          if (year >= startYear && year <= endYear) {
            if (!yearlyData[year]) {
              yearlyData[year] = { temps: [], count: 0 };
            }
            // Use average of max and min for daily average
            const dailyAvg = (record.temperature_2m_max + record.temperature_2m_min) / 2;
            yearlyData[year].temps.push(dailyAvg);
            yearlyData[year].count++;
          }
        });

        // Calculate yearly averages
        const years = Object.keys(yearlyData)
          .map(Number)
          .sort((a, b) => a - b);
          
        const averages = years.map(year => ({
          year,
          avg: yearlyData[year].temps.reduce((a, b) => a + b, 0) / yearlyData[year].temps.length
        }));

        // Calculate trend line
        const n = averages.length;
        const sumX = years.reduce((a, b) => a + b, 0);
        const sumY = averages.reduce((a, b) => a + b.avg, 0);
        const sumXY = averages.reduce((a, b) => a + (b.year * b.avg), 0);
        const sumXX = years.reduce((a, b) => a + (b * b), 0);
        
        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;

        // Create trend line points
        const trendLine = years.map(year => ({
          year,
          value: slope * year + intercept
        }));

        // Update chart data
        trendChart.data.labels = years;
        trendChart.data.datasets = [
          {
            label: 'Average Temperature',
            data: averages.map(point => useMetric ? point.avg : celsiusToFahrenheit(point.avg)),
            borderColor: 'rgb(255, 99, 132)',
            backgroundColor: 'rgba(255, 99, 132, 0.1)',
            fill: true,
            tension: 0.4,
            pointHitRadius: 10
          },
          {
            label: 'Trend Line',
            data: trendLine.map(point => useMetric ? point.value : celsiusToFahrenheit(point.value)),
            borderColor: 'rgba(255, 255, 255, 0.5)',
            borderWidth: 2,
            borderDash: [5, 5],
            fill: false,
            pointRadius: 0
          }
        ];

        // Update chart options
        trendChart.options.plugins.title.text = `Temperature Trend Analysis: ${cityKey} (${startYear}-${endYear})`;
        trendChart.options.scales.y.title.text = useMetric ? 'Average Temperature (°C)' : 'Average Temperature (°F)';
        
        // Calculate total change and rate
        const totalChange = trendLine[trendLine.length - 1].value - trendLine[0].value;
        const ratePerDecade = (totalChange / (endYear - startYear)) * 10;
        
        // Add annotation for trend information
        trendChart.options.plugins.annotation = {
          annotations: {
            trendInfo: {
              type: 'label',
              xValue: years[Math.floor(years.length / 2)],
              yValue: Math.max(...averages.map(p => p.avg)) + 1,
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              content: `Trend: ${ratePerDecade.toFixed(2)}°C per decade`,
              color: 'white',
              font: { size: 12 },
              padding: 6
            }
          }
        };

        trendChart.update();
      } catch (error) {
        console.error('Error updating trend analysis:', error);
      }
    }

    async function updateExtremesAndRainfall() {
      const city = document.getElementById('annualCitySelect').value;
      const year = document.getElementById('annualYearSelect').value;
      
      try {
        // Fetch data from the backend
        const response = await fetch(`http://127.0.0.1:5000/weather/raw?city=${city.charAt(0).toUpperCase() + city.slice(1)}`);
        const data = await response.json();
        
            const cityKey = city.charAt(0).toUpperCase() + city.slice(1);
            const cityData = data[cityKey].filter(record => record.date.startsWith(year));

            // Process data for seasonal extremes
            const seasonalData = {
              Summer: { max: [], min: [] },
              Autumn: { max: [], min: [] },
              Winter: { max: [], min: [] },
              Spring: { max: [], min: [] }
            };

            cityData.forEach(record => {
              const month = new Date(record.date).getMonth();
              let season;
              if (month >= 11 || month <= 1) season = 'Summer';
              else if (month >= 2 && month <= 4) season = 'Autumn';
              else if (month >= 5 && month <= 7) season = 'Winter';
              else season = 'Spring';

              seasonalData[season].max.push(record.temperature_2m_max);
              seasonalData[season].min.push(record.temperature_2m_min);
            });

            // Calculate seasonal extremes
            const extremes = Object.entries(seasonalData).map(([season, data]) => ({
              season,
              max: data.max.length > 0 ? Math.max(...data.max) : null,
              min: data.min.length > 0 ? Math.min(...data.min) : null
            }));

            // Update extremes chart
            extremesChart.data.datasets[0].data = extremes.map(e => 
              e.max !== null ? (useMetric ? e.max : celsiusToFahrenheit(e.max)) : null
            );
            extremesChart.data.datasets[1].data = extremes.map(e => 
              e.min !== null ? (useMetric ? e.min : celsiusToFahrenheit(e.min)) : null
            );
            
            extremesChart.update();

            // Process monthly rainfall data
            const monthlyRain = Array(12).fill(0);
            cityData.forEach(record => {
              const month = new Date(record.date).getMonth();
              monthlyRain[month] += record.precipitation_sum;
            });

            // Update rainfall chart
            monthlyRainChart.data.datasets[0].data = monthlyRain;
            monthlyRainChart.update();
      } catch (error) {
        console.error('Error updating extremes and rainfall:', error);
        }
      }

    function downloadChartImageLocal(chart, filename = 'chart.png') {
      chart.update(); 
      setTimeout(() => {
      const link = document.createElement('a');
      link.href = chart.toBase64Image('image/png', 1.0);
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      }, 300);
    }

    // Add event listeners for forecast city selectors
    document.getElementById('forecastCityA').addEventListener('change', updateForecastChart);
    document.getElementById('forecastCityB').addEventListener('change', updateForecastChart);
  </script>

  <!-- Add this right before the closing </body> tag -->
    <!-- Chat Interface -->
    <div id="chat-container" class="fixed bottom-4 right-4 w-96 bg-secondary-800 rounded-lg shadow-xl transition-all duration-300 transform" style="z-index: 1000;">
      <!-- Chat Header -->
      <div class="flex items-center justify-between p-4 bg-primary-600 rounded-t-lg cursor-pointer" id="chat-header">
        <div class="flex items-center">
          <i class="fas fa-robot mr-2 text-white"></i>
          <h3 class="text-white font-semibold">Weather Assistant</h3>
        </div>
        <div class="flex items-center">
          <button id="minimize-chat" class="text-white hover:text-gray-200 focus:outline-none">
            <i class="fas fa-minus"></i>
          </button>
        </div>
      </div>
      
      <!-- Chat Messages -->
      <div id="chat-messages" class="h-96 overflow-y-auto p-4 space-y-4" style="display: none;">
        <!-- Welcome Message -->
        <div class="flex items-start">
          <div class="flex-shrink-0">
            <div class="w-8 h-8 rounded-full bg-primary-500 flex items-center justify-center">
              <i class="fas fa-robot text-white text-sm"></i>
            </div>
          </div>
          <div class="ml-3 bg-primary-500 rounded-lg p-3 max-w-[80%]">
            <p class="text-white">Hello! I'm your weather assistant. How can I help you today?</p>
          </div>
        </div>
      </div>
      
      <!-- Chat Input -->
      <div id="chat-input" class="p-4 border-t border-secondary-700" style="display: none;">
        <div class="flex items-center">
          <input type="text" id="user-input" 
                 class="flex-1 bg-secondary-700 text-white rounded-l-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-primary-500"
                 placeholder="Ask about weather...">
          <button id="send-message" 
                  class="bg-primary-500 text-white px-4 py-2 rounded-r-lg hover:bg-primary-600 focus:outline-none focus:ring-2 focus:ring-primary-500">
            <i class="fas fa-paper-plane"></i>
          </button>
        </div>
      </div>
    </div>

    <script>
      // Add this to your existing JavaScript code
      document.addEventListener('DOMContentLoaded', function() {
        const chatContainer = document.getElementById('chat-container');
        const chatHeader = document.getElementById('chat-header');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-message');
        const minimizeButton = document.getElementById('minimize-chat');
        let isChatOpen = false;

        // Toggle chat visibility
        function toggleChat() {
          isChatOpen = !isChatOpen;
          chatMessages.style.display = isChatOpen ? 'block' : 'none';
          chatInput.style.display = isChatOpen ? 'block' : 'none';
          minimizeButton.innerHTML = isChatOpen ? '<i class="fas fa-minus"></i>' : '<i class="fas fa-plus"></i>';
        }

        chatHeader.addEventListener('click', function(e) {
          if (e.target !== minimizeButton && e.target !== minimizeButton.querySelector('i')) {
            toggleChat();
          }
        });

        minimizeButton.addEventListener('click', toggleChat);

        // Send message function
        function sendMessage() {
          const message = userInput.value.trim();
          if (message) {
            // Add user message
            addMessage(message, true);
            
            // Process the message and get AI response
            processMessage(message);
            
            // Clear input
            userInput.value = '';
          }
        }

        // Add message to chat
        function addMessage(message, isUser = false) {
          const messageDiv = document.createElement('div');
          messageDiv.className = 'flex items-start ' + (isUser ? 'justify-end' : '');
          
          const iconAndMessage = `
            ${isUser ? '' : `
              <div class="flex-shrink-0">
                <div class="w-8 h-8 rounded-full bg-primary-500 flex items-center justify-center">
                  <i class="fas fa-robot text-white text-sm"></i>
                </div>
              </div>
            `}
            <div class="ml-3 ${isUser ? 'bg-primary-600' : 'bg-primary-500'} rounded-lg p-3 max-w-[80%]">
              <p class="text-white">${message}</p>
            </div>
          `;
          
          messageDiv.innerHTML = iconAndMessage;
          chatMessages.appendChild(messageDiv);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Replace the processMessage function with this enhanced version
        async function processMessage(message) {
          const lowerMessage = message.toLowerCase();
          let response = '';
          
          // Get current city and weather data
          const currentCity = document.getElementById('currentCitySelect').value;
          const cityName = currentCity.charAt(0).toUpperCase() + currentCity.slice(1);
          
          // Helper function to get weather data
          function getWeatherData(type) {
            const element = document.querySelector(`[data-weather="${type}"]`);
            return element ? element.getAttribute('data-value') || element.textContent : null;
          }

          // Complex pattern matching for various weather queries
          if (lowerMessage.match(/^(hi|hello|hey|greetings)/)) {
            response = `Hello! I'm your weather assistant for ${cityName}. You can ask me about:
            • Current weather conditions
            • Temperature and feels like
            • Wind speed and direction
            • Humidity and UV index
            • Rainfall and forecast
            • Weather comparisons between cities`;

          } else if (lowerMessage.includes('help') || lowerMessage.includes('what can you do')) {
            response = `I can help you with:
            • Current weather updates
            • Detailed forecasts
            • Weather comparisons
            • Weather alerts and conditions
            • Sunrise/sunset times
            Just ask me anything about the weather!`;

          } else if (lowerMessage.match(/what('s|\s+is)\s+the\s+weather(\s+like)?/) || lowerMessage.match(/how('s|\s+is)\s+the\s+weather/) || lowerMessage.match(/current\s+weather/)) {
            const temp = getWeatherData('temperature');
            const wind = getWeatherData('wind');
            const humidity = getWeatherData('humidity');
            const rain = getWeatherData('rain');
            const uv = getWeatherData('uv');

            let conditions = [];
            
            // Temperature assessment
            if (parseFloat(temp) > 30) conditions.push("very hot");
            else if (parseFloat(temp) > 25) conditions.push("warm");
            else if (parseFloat(temp) > 15) conditions.push("mild");
            else if (parseFloat(temp) > 10) conditions.push("cool");
            else conditions.push("cold");

            // Wind assessment
            if (parseFloat(wind) > 30) conditions.push("windy");
            else if (parseFloat(wind) > 15) conditions.push("breezy");

            // Humidity assessment
            if (parseFloat(humidity) > 70) conditions.push("humid");
            else if (parseFloat(humidity) < 30) conditions.push("dry");

            const weatherDescription = conditions.length > 0 
              ? `It's ${conditions.join(" and ")} today.` 
              : "Weather conditions are moderate today.";

            response = `Current weather in ${cityName}:
            ${weatherDescription}
            
            Detailed conditions:
            • Temperature: ${formatTemperature(temp)}
            • Wind Speed: ${formatWindSpeed(wind)}
            • Humidity: ${humidity}%
            • Rainfall: ${rain}
            • UV Index: ${uv}
            
            Would you like more specific details about any of these conditions?`;

          } else if (lowerMessage.match(/(temperature|how (hot|cold|warm))/)) {
            const temp = getWeatherData('temperature');
            const humidity = getWeatherData('humidity');
            response = `In ${cityName}, the current temperature is ${formatTemperature(temp)}. 
            With ${humidity}% humidity, it ${parseFloat(temp) > 25 ? 'might feel quite warm' : 
            parseFloat(temp) < 15 ? 'might feel a bit chilly' : 'should feel comfortable'}.`;

          } else if (lowerMessage.match(/(wind|breezy|windy)/)) {
            const wind = getWeatherData('wind');
            response = `The wind speed in ${cityName} is currently ${formatWindSpeed(wind)}. 
            ${parseFloat(wind) > 30 ? 'It\'s quite windy today!' : 
            parseFloat(wind) > 15 ? 'There\'s a moderate breeze.' : 'The wind is fairly light.'}`;

          } else if (lowerMessage.match(/(humidity|humid|moisture)/)) {
            const humidity = getWeatherData('humidity');
            response = `The current humidity in ${cityName} is ${humidity}%. 
            ${parseFloat(humidity) > 70 ? 'It\'s quite humid today.' : 
            parseFloat(humidity) < 30 ? 'It\'s relatively dry today.' : 'This is a comfortable humidity level.'}`;

          } else if (lowerMessage.match(/(rain|rainfall|precipitation)/)) {
            const rain = getWeatherData('rain');
            response = `${cityName} has received ${rain} of rainfall. 
            ${parseFloat(rain) > 10 ? 'That\'s significant rainfall!' : 
            parseFloat(rain) > 5 ? 'We\'ve had moderate rainfall.' : 
            parseFloat(rain) > 0 ? 'We\'ve had light rainfall.' : 'No rainfall recorded.'}`;

          } else if (lowerMessage.match(/(uv|ultra\s*violet)/)) {
            const uv = getWeatherData('uv');
            let uvAdvice = '';
            if (parseFloat(uv) >= 8) uvAdvice = 'Take extra precautions against sun exposure!';
            else if (parseFloat(uv) >= 5) uvAdvice = 'Use sun protection when outdoors.';
            else if (parseFloat(uv) >= 2) uvAdvice = 'Moderate UV levels, basic sun protection is advised.';
            else uvAdvice = 'UV levels are low, but basic sun protection is still recommended.';
            response = `The UV index in ${cityName} is ${uv}. ${uvAdvice}`;

          } else if (lowerMessage.match(/(forecast|weather\s+tomorrow|next\s+days?)/)) {
            response = `I can tell you about the 7-day forecast for ${cityName}. 
            You can view the detailed forecast chart in the forecast section, which shows:
            • Daily temperature ranges
            • Expected conditions
            • Rainfall probability
            Would you like me to explain how to read the forecast chart?`;

          } else if (lowerMessage.match(/(pressure|barometric|atmospheric)/)) {
            const pressure = getWeatherData('pressure');
            response = `The atmospheric pressure in ${cityName} is ${pressure} hPa. 
            ${parseFloat(pressure) > 1013 ? 'This high pressure typically indicates stable weather.' : 
            'This low pressure might indicate changing weather conditions.'}`;

          } else if (lowerMessage.match(/(visibility|clear|fog|foggy)/)) {
            const visibility = getWeatherData('visibility');
            response = `Current visibility in ${cityName} is ${visibility}. 
            ${parseFloat(visibility) > 10 ? 'Visibility is excellent!' : 
            parseFloat(visibility) > 5 ? 'Visibility is good.' : 'Visibility is reduced.'}`;

          } else if (lowerMessage.match(/(compare|difference|between cities)/)) {
            response = `I can help you compare weather between cities. You can:
            • View temperature differences
            • Compare rainfall patterns
            • Check wind speed variations
            Use the comparison tools in the forecast section for detailed analysis.`;

          } else if (lowerMessage.match(/(weather|conditions|what's it like)/)) {
            const temp = getWeatherData('temperature');
            const wind = getWeatherData('wind');
            const humidity = getWeatherData('humidity');
            response = `Here's the current weather in ${cityName}:
            • Temperature: ${formatTemperature(temp)}
            • Wind Speed: ${formatWindSpeed(wind)}
            • Humidity: ${humidity}%
            Would you like more specific details about any of these conditions?`;

          } else {
            response = `I'm not sure about that, but I can help you with:
            • Current weather conditions
            • Temperature and wind information
            • Humidity and UV levels
            • Rainfall and forecasts
            • City weather comparisons
            Just ask me about any of these topics!`;
          }
          
          // Add AI response with a slight delay to feel more natural
          setTimeout(() => addMessage(response), 500);
        }

        // Event listeners
        sendButton.addEventListener('click', sendMessage);
        userInput.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            sendMessage();
          }
        });
      });
  </script>
</body>
</html>